<!DOCTYPE html>
<html lang="en">

<head>
	<title>T3 - To The Top</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
	<style>
		canvas{
			position: relative;
		}
		progress{
			z-index: 1;
			position: absolute;
			top: 50%;
			left: 80%;
			rotate: -90deg;
		}
	</style>
</head>

<body style="overflow-y:hidden">
	<div id="info" style="width: 100%; height: 5rem; text-align: center;">
		<progress id = "powerLevel" value="1" max="2" style="width:30%; height: inherit;"></progress>
	</div>
	<div id="container"></div>
	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

	<canvas id="gl-canvas" width="1280" height="720">
		Oops ... your browser doesn't support the HTML5 canvas element
	</canvas>

	<script type="importmap">
			{
				"imports": {
					"three": "../three.js-master/build/three.module.js",
					"three/addons/": "../three.js-master/examples/jsm/"
				}
			}
		</script>

	<script type="module">

		import * as THREE from 'three';

		import Stats from 'three/addons/libs/stats.module.js';

		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

		import { Octree } from 'three/addons/math/Octree.js';
		import { OctreeHelper } from 'three/addons/helpers/OctreeHelper.js';

		import { Capsule } from 'three/addons/math/Capsule.js';

		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
		import { RandomObjectGeneration } from "../Random_object_generation.module.js";

		const clock = new THREE.Clock();

		const scene = new THREE.Scene();
		scene.background = new THREE.Color(0x88ccee);
		scene.fog = new THREE.Fog(0x88ccee, 0, 50);

		const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
		camera.rotation.order = 'YXZ';

		const fillLight1 = new THREE.HemisphereLight(0x4488bb, 0x002244, 0.5);
		fillLight1.position.set(2, 1, 1);
		scene.add(fillLight1);

		const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
		directionalLight.position.set(- 5, 25, - 1);
		directionalLight.castShadow = true;
		directionalLight.shadow.camera.near = 0.01;
		directionalLight.shadow.camera.far = 500;
		directionalLight.shadow.camera.right = 30;
		directionalLight.shadow.camera.left = - 30;
		directionalLight.shadow.camera.top = 30;
		directionalLight.shadow.camera.bottom = - 30;
		directionalLight.shadow.mapSize.width = 1024;
		directionalLight.shadow.mapSize.height = 1024;
		directionalLight.shadow.radius = 4;
		directionalLight.shadow.bias = - 0.00006;
		scene.add(directionalLight);

		const container = document.getElementById('container');

		const renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.VSMShadowMap;
		renderer.outputEncoding = THREE.sRGBEncoding;
		renderer.toneMapping = THREE.ACESFilmicToneMapping;
		container.appendChild(renderer.domElement);
		
		const stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		container.appendChild(stats.domElement);

		const GRAVITY = 30;

		const NUM_SPHERES = 100;
		const SPHERE_RADIUS = 0.2;

		const STEPS_PER_FRAME = 5;

		const sphereGeometry = new THREE.IcosahedronGeometry(SPHERE_RADIUS, 5);
		const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0xbbbb44 });

		var portal;

		const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
		sphere.castShadow = true;
		sphere.receiveShadow = true;

		scene.add(sphere);

		portal = {
			mesh: sphere,
			collider: new THREE.Sphere(new THREE.Vector3(0, - 100, 0), SPHERE_RADIUS),
			velocity: new THREE.Vector3()
		};

		const worldOctree = new Octree();

		const playerCollider = new Capsule(new THREE.Vector3(0, 0.35, 0), new THREE.Vector3(0, 1, 0), 0.35);

		const playerVelocity = new THREE.Vector3();
		const playerDirection = new THREE.Vector3();

		let playerOnFloor = false;
		let mouseTime = 0;

		const keyStates = {};

		const vector1 = new THREE.Vector3();
		const vector2 = new THREE.Vector3();
		const vector3 = new THREE.Vector3();

		

		var ballPower = 1;

		document.addEventListener('keydown', (event) => {

			console.log(event.code);
			keyStates[event.code] = true;

		});

		document.addEventListener('keyup', (event) => {

			keyStates[event.code] = false;

		});

		container.addEventListener('mousedown', () => {

			document.body.requestPointerLock();

			mouseTime = performance.now();

		});

		document.addEventListener('mouseup', () => {

			if (document.pointerLockElement !== null) throwBall();

		});

		document.body.addEventListener('mousemove', (event) => {

			if (document.pointerLockElement === document.body) {

				camera.rotation.y -= event.movementX / 500;
				camera.rotation.x -= event.movementY / 500;

			}

		});

		window.addEventListener('resize', onWindowResize);

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function throwBall() {

			const sphere = portal;

			camera.getWorldDirection(playerDirection);

			sphere.collider.center.copy(playerCollider.end).addScaledVector(playerDirection, playerCollider.radius * 1.5);

			// throw the ball with more force if we hold the button longer, and if we move forward

			//기존 던지는 코드에 파워를 곱해버려서 속도 조절
			const impulse = 15 + 30 * (1 - Math.exp((mouseTime - performance.now()) * 0.001)) * ballPower;

			sphere.velocity.copy(playerDirection).multiplyScalar(impulse);
			sphere.velocity.addScaledVector(playerVelocity, 2);

		}

		function playerCollisions() {

			const result = worldOctree.capsuleIntersect(playerCollider);

			playerOnFloor = false;

			if (result) {

				playerOnFloor = result.normal.y > 0;

				if (!playerOnFloor) {

					playerVelocity.addScaledVector(result.normal, - result.normal.dot(playerVelocity));

				}

				playerCollider.translate(result.normal.multiplyScalar(result.depth));

			}

		}

		function updatePlayer(deltaTime) {

			let damping = Math.exp(- 4 * deltaTime) - 1;

			if (!playerOnFloor) {

				playerVelocity.y -= GRAVITY * deltaTime;

				// small air resistance
				damping *= 0.1;

			}

			playerVelocity.addScaledVector(playerVelocity, damping);

			const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
			playerCollider.translate(deltaPosition);
			

			playerCollisions();

			camera.position.copy(playerCollider.end);

		}

		function updateSpheres(deltaTime) {


			portal.collider.center.addScaledVector(portal.velocity, deltaTime);

			const result = worldOctree.sphereIntersect(portal.collider);

			if (result) {

				portal.velocity.addScaledVector(result.normal, - result.normal.dot(portal.velocity) * 1.5);
				portal.collider.center.add(result.normal.multiplyScalar(result.depth));

				portal.velocity.addScaledVector(new THREE.Vector3(0,0,0));

				playerCollider.start.set(portal.collider.center.x,portal.collider.center.y+0.35,portal.collider.center.z);
				playerCollider.end.set(portal.collider.center.x,portal.collider.center.y+1,portal.collider.center.z);
				playerCollider.radius = 0.35;
				camera.position.copy(playerCollider.end);
				camera.rotation.set(0, 0, 0);
				
				console.log(portal.collider.center.x,portal.collider.center.y,portal.collider.center.z);

			} else {

				portal.velocity.y -= GRAVITY * deltaTime;

			}

			const damping = Math.exp(- 1.5 * deltaTime) - 1;
			portal.velocity.addScaledVector(portal.velocity, damping);

			portal.mesh.position.copy(portal.collider.center);

		}

		function getForwardVector() {

			camera.getWorldDirection(playerDirection);
			playerDirection.y = 0;
			playerDirection.normalize();

			return playerDirection;

		}

		function getSideVector() {

			camera.getWorldDirection(playerDirection);
			playerDirection.y = 0;
			playerDirection.normalize();
			playerDirection.cross(camera.up);

			return playerDirection;

		}

		//파워 레벨 올리는 로직
		function levelUpper(){
			var powerLevel = document.querySelector("#powerLevel");
			console.log(powerLevel);
			if(ballPower < 2) ballPower = ballPower + 0.01;

			powerLevel.value = ballPower;
		}

		//파워레벨 내리는 로직
		function levelDowner(){
			var powerLevel = document.querySelector("#powerLevel");
			
			if(ballPower > 0) ballPower = ballPower - 0.01;

			powerLevel.value = ballPower;
		}

		function controls(deltaTime) {

			// gives a bit of air control
			const speedDelta = deltaTime * (playerOnFloor ? 25 : 8);
			
			//비동기로 파워 레벨 올리는 콜백
			const asyncLevelUpper = async () => {
				await levelUpper();
			}
			//비동기로 파워 레벨 내리는 콜백
			const asyncLevelDowner = async () => {
				await levelDowner();
			}

			if (keyStates['KeyW']) {

				playerVelocity.add(getForwardVector().multiplyScalar(speedDelta));

			}

			if (keyStates['KeyS']) {

				playerVelocity.add(getForwardVector().multiplyScalar(- speedDelta));

			}

			if (keyStates['KeyA']) {

				playerVelocity.add(getSideVector().multiplyScalar(- speedDelta));

			}

			if (keyStates['KeyD']) {

				playerVelocity.add(getSideVector().multiplyScalar(speedDelta));

			}

			//	방향키 위 키를 누르면 파워 올라감
			if(keyStates['ArrowUp']) {
				asyncLevelUpper();
			}

			// 방향키 아래 키를 누르면 파워 내려감
			if(keyStates['ArrowDown']) {
				asyncLevelDowner();
			}
		}


		//Box 생성
		var objects_floor = new RandomObjectGeneration(0, 0, 0, 100, 0, 100,"../water.jpg");

		var objects_box1 = new RandomObjectGeneration(0, 10, 0, 5, 5, 5);
		var objects_box2 = new RandomObjectGeneration(10, 20, 0, 5, 5, 5);
		var objects_box3 = new RandomObjectGeneration(-10, 40, 0, 5, 5, 5);
		var objects_box4 = new RandomObjectGeneration(0, 50, 20, 5, 5, 5);
		var objects_box5 = new RandomObjectGeneration(0, 70, -10, 5, 5, 5);


		//씬에 추가
		scene.add(objects_floor.floor);
		scene.add(objects_box1.floor);
		scene.add(objects_box2.floor);
		scene.add(objects_box3.floor);
		scene.add(objects_box4.floor);
		scene.add(objects_box5.floor);

		//충돌판정을 추가
		worldOctree.fromGraphNode(objects_floor.floor);
		worldOctree.fromGraphNode(objects_box1.floor);
		worldOctree.fromGraphNode(objects_box2.floor);
		worldOctree.fromGraphNode(objects_box3.floor);
		worldOctree.fromGraphNode(objects_box4.floor);
		worldOctree.fromGraphNode(objects_box5.floor);

		const helper = new OctreeHelper(worldOctree);
		helper.visible = false;
		scene.add(helper);

		const gui = new GUI({ width: 200 });
		gui.add({ debug: false }, 'debug')
			.onChange(function (value) {

				helper.visible = value;

			});

		animate();

		
		function teleportPlayerIfOob() {

			if (camera.position.y <= - 25) {

				playerCollider.start.set(0, 0.35, 0);
				playerCollider.end.set(0, 1, 0);
				playerCollider.radius = 0.35;
				camera.position.copy(playerCollider.end);
				camera.rotation.set(0, 0, 0);

			}

		}


		function animate() {

			const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;

			// we look for collisions in substeps to mitigate the risk of
			// an object traversing another too quickly for detection.

			for (let i = 0; i < STEPS_PER_FRAME; i++) {

				controls(deltaTime);

				updatePlayer(deltaTime);

				updateSpheres(deltaTime);

				teleportPlayerIfOob();

			}

			renderer.render(scene, camera);

			stats.update();

			requestAnimationFrame(animate);

		}

	</script>
</body>

</html>